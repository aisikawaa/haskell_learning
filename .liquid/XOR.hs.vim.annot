1:1-1:1::Main.$trModule :: "GHC.Types.Module"
2:1-2:8::Main.xorBool :: "GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool"
2:9-2:15::value1 :: "GHC.Types.Bool"
2:16-2:22::value2 :: "GHC.Types.Bool"
2:25-2:43::lq_anf$##7205759403792806095 :: "{v : GHC.Types.Bool | v <=> value1\n                            || value2}"
2:26-2:32::value1 :: "{v : GHC.Types.Bool | v == value1}"
2:36-2:42::value2 :: "{v : GHC.Types.Bool | v == value2}"
2:47-2:70::lq_anf$##7205759403792806097 :: "GHC.Types.Bool"
2:51-2:69::lq_anf$##7205759403792806096 :: "{v : GHC.Types.Bool | v <=> value1\n                            && value2}"
2:52-2:58::value1 :: "{v : GHC.Types.Bool | v == value1}"
2:62-2:68::value2 :: "{v : GHC.Types.Bool | v == value2}"
5:1-5:8::Main.xorPair :: "(GHC.Types.Bool, GHC.Types.Bool) -> GHC.Types.Bool"
5:19-5:32::Main.xorBool :: "GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool"
5:27-5:29::v1 :: "{v : GHC.Types.Bool | v == v1}"
5:30-5:32::v2 :: "{v : GHC.Types.Bool | v == v2}"
8:1-8:4::Main.xor :: "[GHC.Types.Bool] -> [GHC.Types.Bool] -> [GHC.Types.Bool]"
8:5-8:10::list1 :: "[GHC.Types.Bool]"
8:11-8:16::list2 :: "[GHC.Types.Bool]"
8:23-8:30::Main.xorPair :: "(GHC.Types.Bool, GHC.Types.Bool) -> GHC.Types.Bool"
8:31-8:48::lq_anf$##7205759403792806099 :: "{v : [(GHC.Types.Bool, GHC.Types.Bool)] | len v <= len list1\n                                          && len v <= len list2\n                                          && (len list1 == len list2 => len v == len list1)}"
8:36-8:41::list1 :: "{v : [GHC.Types.Bool] | len v >= 0\n                        && v == list1}"
8:42-8:47::list2 :: "{v : [GHC.Types.Bool] | len v >= 0\n                        && v == list2}"
12:1-12:11::Main.intToBits' :: "GHC.Types.Int -> [GHC.Types.Bool]"
12:16-12:23::lq_anf$##7205759403792806112 :: "{v : [GHC.Types.Bool] | len v == 0}"
12:17-12:22::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
13:16-13:22::lq_anf$##7205759403792806113 :: "{v : [GHC.Types.Bool] | len v == 0}"
13:17-13:21::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
14:19-14:35::lq_anf$##7205759403792806108 :: "GHC.Types.Bool"
14:20-14:29::remainder :: "{v : GHC.Types.Int | v == remainder}"
14:33-14:34::lq_anf$##7205759403792806107 :: "GHC.Types.Int"
15:21-15:26::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
15:29-15:47::lq_anf$##7205759403792806111 :: "[GHC.Types.Bool]"
15:40-15:47::nextVal :: "{v : GHC.Types.Int | v == nextVal}"
16:21-16:25::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
16:28-16:46::lq_anf$##7205759403792806110 :: "[GHC.Types.Bool]"
16:39-16:46::nextVal :: "{v : GHC.Types.Int | v == nextVal}"
18:9-18:18::remainder :: "GHC.Types.Int"
18:21-18:22::ds_d3eY :: "GHC.Types.Int"
18:29-18:30::lq_anf$##7205759403792806105 :: "GHC.Types.Int"
19:9-19:16::nextVal :: "GHC.Types.Int"
19:19-19:20::ds_d3eY :: "GHC.Types.Int"
19:27-19:28::lq_anf$##7205759403792806103 :: "GHC.Types.Int"
22:1-22:8::Main.maxBits :: "GHC.Types.Int"
22:18-22:39::lq_anf$##7205759403792806115 :: "[GHC.Types.Bool]"
22:30-22:38::lq_anf$##7205759403792806114 :: "GHC.Types.Int"
25:1-25:10::Main.intToBits :: "GHC.Types.Int -> [GHC.Types.Bool]"
25:11-25:12::n :: "GHC.Types.Int"
25:15-25:28::leadingFalses :: "{v : [GHC.Types.Bool] | (not (missingBits >= 0) => len v == 0)\n                        && len v >= 0\n                        && v == leadingFalses}"
25:32-25:43::reverseBits :: "{v : [GHC.Types.Bool] | len v >= 0\n                        && v == reverseBits}"
26:9-26:20::reverseBits :: "[GHC.Types.Bool]"
26:23-26:45::_ :: "[GHC.Types.Bool]"
26:31-26:45::lq_anf$##7205759403792806116 :: "[GHC.Types.Bool]"
26:43-26:44::n :: "{v : GHC.Types.Int | v == n}"
27:9-27:20::missingBits :: "GHC.Types.Int"
27:23-27:30::Main.maxBits :: "{v : GHC.Types.Int | v == maxBits}"
27:33-27:53::lq_anf$##7205759403792806117 :: "{v : GHC.Types.Int | v >= 0\n                     && v == len reverseBits}"
27:41-27:52::reverseBits :: "{v : [GHC.Types.Bool] | len v >= 0\n                        && v == reverseBits}"
28:9-28:22::leadingFalses :: "{v : [GHC.Types.Bool] | not (missingBits >= 0) => len v == 0}"
28:25-28:57::_ :: "{v : [GHC.Types.Bool] | not (missingBits >= 0) => len v == 0}"
28:30-28:41::missingBits :: "{v : GHC.Types.Int | v == missingBits}"
28:42-28:57::lq_anf$##7205759403792806120 :: "[GHC.Types.Bool]"
28:49-28:56::lq_anf$##7205759403792806119 :: "{v : [GHC.Types.Bool] | head v == False}"
28:50-28:55::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
31:1-31:11::Main.charToBits :: "GHC.Types.Char -> [GHC.Types.Bool]"
31:12-31:16::char :: "GHC.Types.Char"
31:29-31:44::lq_anf$##7205759403792806121 :: "GHC.Types.Int"
31:39-31:43::char :: "{v : GHC.Types.Char | v == char}"
34:1-34:10::Main.bitsToInt :: "[GHC.Types.Bool] -> GHC.Types.Int"
34:11-34:15::bits :: "[GHC.Types.Bool]"
34:18-34:59::GHC.Num.$fNumInt :: "{v : (GHC.Num.Num GHC.Types.Int) | v == $fNumInt}"
34:22-34:59::lq_anf$##7205759403792806141 :: "{v : [GHC.Types.Int] | len v == len trueLocations}"
34:27-34:44::GHC.Real.$fIntegralInt :: "{v : (GHC.Real.Integral GHC.Types.Int) | v == $fIntegralInt}"
34:29-34:30::x :: "(GHC.Types.Bool, GHC.Types.Int)"
34:34-34:35::lq_anf$##7205759403792806138 :: "GHC.Types.Int"
34:36-34:43::lq_anf$##7205759403792806139 :: "{v : GHC.Types.Int | v == snd x}"
34:41-34:42::x :: "{v : (GHC.Types.Bool, GHC.Types.Int) | v == x}"
34:45-34:58::trueLocations :: "{v : [(GHC.Types.Bool, GHC.Types.Int)] | len v >= 0\n                                         && v == trueLocations}"
35:9-35:13::size :: "{v : GHC.Types.Int | v >= 0\n                     && v == len bits}"
35:16-35:27::_ :: "{v : GHC.Types.Int | v >= 0\n                     && v == len bits}"
35:23-35:27::bits :: "{v : [GHC.Types.Bool] | len v >= 0\n                        && v == bits}"
36:9-36:16::indices :: "[GHC.Types.Int]"
36:19-36:40::_ :: "[GHC.Types.Int]"
36:20-36:24::size :: "{v : GHC.Types.Int | v >= 0\n                     && v == len bits\n                     && v == size}"
36:25-36:26::lq_anf$##7205759403792806127 :: "GHC.Types.Int"
36:28-36:32::size :: "{v : GHC.Types.Int | v >= 0\n                     && v == len bits\n                     && v == size}"
36:33-36:34::lq_anf$##7205759403792806130 :: "GHC.Types.Int"
36:38-36:39::lq_anf$##7205759403792806133 :: "GHC.Types.Int"
37:9-37:22::trueLocations :: "[(GHC.Types.Bool, GHC.Types.Int)]"
37:32-37:53::GHC.Classes.$fEqBool :: "{v : (GHC.Classes.Eq GHC.Types.Bool) | v == $fEqBool}"
37:34-37:35::x :: "(GHC.Types.Bool, GHC.Types.Int)"
37:39-37:44::lq_anf$##7205759403792806134 :: "{v : GHC.Types.Bool | v == fst x}"
37:43-37:44::x :: "{v : (GHC.Types.Bool, GHC.Types.Int) | v == x}"
37:48-37:52::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
38:25-38:43::lq_anf$##7205759403792806136 :: "{v : [(GHC.Types.Bool, GHC.Types.Int)] | len v <= len bits\n                                         && len v <= len indices\n                                         && (len bits == len indices => len v == len bits)}"
38:30-38:34::bits :: "{v : [GHC.Types.Bool] | len v >= 0\n                        && v == bits}"
38:35-38:42::indices :: "{v : [GHC.Types.Int] | len v >= 0\n                       && v == indices}"
41:1-41:11::Main.bitsToChar :: "[GHC.Types.Bool] -> GHC.Types.Char"
41:12-41:16::bits :: "[GHC.Types.Bool]"
41:26-41:42::lq_anf$##7205759403792806142 :: "GHC.Types.Int"
41:37-41:41::bits :: "{v : [GHC.Types.Bool] | len v >= 0\n                        && v == bits}"
44:1-44:6::Main.myPad :: "[GHC.Types.Char]"
47:1-47:12::Main.myPlainText :: "[GHC.Types.Char]"
50:1-50:10::Main.applyOTP' :: "[GHC.Types.Char] -> [GHC.Types.Char] -> [[GHC.Types.Bool]]"
50:11-50:14::pad :: "[GHC.Types.Char]"
50:15-50:24::plaintext :: "[GHC.Types.Char]"
50:31-50:69::Main.xor :: "[GHC.Types.Bool] -> [GHC.Types.Bool] -> [GHC.Types.Bool]"
50:33-50:37::pair :: "([GHC.Types.Bool], [GHC.Types.Bool])"
50:41-50:51::lq_anf$##7205759403792806122 :: "{v : [GHC.Types.Bool] | v == fst pair}"
50:46-50:50::pair :: "{v : ([GHC.Types.Bool], [GHC.Types.Bool]) | v == pair}"
50:58-50:68::lq_anf$##7205759403792806123 :: "{v : [GHC.Types.Bool] | v == snd pair}"
50:63-50:67::pair :: "{v : ([GHC.Types.Bool], [GHC.Types.Bool]) | v == pair}"
51:31-51:58::lq_anf$##7205759403792806125 :: "{v : [([GHC.Types.Bool], [GHC.Types.Bool])] | len v <= len padBits\n                                              && len v <= len plaintextBits\n                                              && (len padBits == len plaintextBits => len v == len padBits)}"
51:36-51:43::padBits :: "{v : [[GHC.Types.Bool]] | len v == len pad\n                          && len v >= 0\n                          && v == padBits}"
51:44-51:57::plaintextBits :: "{v : [[GHC.Types.Bool]] | len v == len plaintext\n                          && len v >= 0\n                          && v == plaintextBits}"
53:9-53:16::padBits :: "{v : [[GHC.Types.Bool]] | len v == len pad}"
53:19-53:37::_ :: "{v : [[GHC.Types.Bool]] | len v == len pad}"
53:23-53:33::Main.charToBits :: "GHC.Types.Char -> [GHC.Types.Bool]"
53:34-53:37::pad :: "{v : [GHC.Types.Char] | len v >= 0\n                        && v == pad}"
54:9-54:22::plaintextBits :: "{v : [[GHC.Types.Bool]] | len v == len plaintext}"
54:25-54:49::_ :: "{v : [[GHC.Types.Bool]] | len v == len plaintext}"
54:29-54:39::Main.charToBits :: "GHC.Types.Char -> [GHC.Types.Bool]"
54:40-54:49::plaintext :: "{v : [GHC.Types.Char] | len v >= 0\n                        && v == plaintext}"
57:1-57:9::Main.applyOTP :: "[GHC.Types.Char] -> [GHC.Types.Char] -> [GHC.Types.Char]"
57:10-57:13::pad :: "[GHC.Types.Char]"
57:14-57:23::plaintext :: "[GHC.Types.Char]"
57:26-57:48::GHC.Base.map :: "{VV : forall a##xo b##xo .\n      (a##xo -> b##xo) -> x3:[a##xo] -> {v : [b##xo] | len v == len x3} | VV == map}"
57:30-57:40::Main.bitsToChar :: "[GHC.Types.Bool] -> GHC.Types.Char"
57:41-57:48::bitList :: "{v : [[GHC.Types.Bool]] | len v >= 0\n                          && v == bitList}"
58:9-58:16::bitList :: "[[GHC.Types.Bool]]"
58:19-58:42::_ :: "[[GHC.Types.Bool]]"
58:29-58:32::pad :: "{v : [GHC.Types.Char] | len v >= 0\n                        && v == pad}"
58:33-58:42::plaintext :: "{v : [GHC.Types.Char] | len v >= 0\n                        && v == plaintext}"
61:1-61:15::Main.encoderDecoder :: "[GHC.Types.Char] -> [GHC.Types.Char]"
61:27-61:32::Main.myPad :: "{v : [GHC.Types.Char] | len v >= 0\n                        && v == myPad}"
69:10-69:27::Main.$fChiperOneTimePad :: "(Main.Chiper Main.OneTimePad)"
70:3-70:9::$cencode :: "Main.OneTimePad -> [GHC.Types.Char] -> [GHC.Types.Char]"
70:20-70:24::text :: "[GHC.Types.Char]"
70:27-70:44::Main.applyOTP :: "[GHC.Types.Char] -> [GHC.Types.Char] -> [GHC.Types.Char]"
70:36-70:39::pad :: "{v : [GHC.Types.Char] | len v >= 0\n                        && v == pad}"
70:40-70:44::text :: "{v : [GHC.Types.Char] | len v >= 0\n                        && v == text}"
71:3-71:9::$cdecode :: "Main.OneTimePad -> [GHC.Types.Char] -> [GHC.Types.Char]"
71:20-71:24::text :: "[GHC.Types.Char]"
71:27-71:44::Main.applyOTP :: "[GHC.Types.Char] -> [GHC.Types.Char] -> [GHC.Types.Char]"
71:36-71:39::pad :: "{v : [GHC.Types.Char] | len v >= 0\n                        && v == pad}"
71:40-71:44::text :: "{v : [GHC.Types.Char] | len v >= 0\n                        && v == text}"
74:1-74:6::Main.myOTP :: "Main.OneTimePad"
74:13-74:43::lq_anf$##7205759403792806150 :: "[GHC.Types.Char]"
74:20-74:42::lq_anf$##7205759403792806149 :: "[GHC.Types.Char]"
74:21-74:29::lq_anf$##7205759403792806147 :: "GHC.Types.Char"
74:33-74:41::lq_anf$##7205759403792806148 :: "GHC.Types.Char"
77:1-77:5::Main.prng :: "GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int"
77:6-77:7::a :: "GHC.Types.Int"
77:8-77:9::b :: "GHC.Types.Int"
77:10-77:19::maxNumber :: "GHC.Types.Int"
77:20-77:24::seed :: "GHC.Types.Int"
77:27-77:39::lq_anf$##7205759403792806152 :: "GHC.Types.Int"
77:28-77:29::a :: "{v : GHC.Types.Int | v == a}"
77:30-77:34::seed :: "{v : GHC.Types.Int | v == seed}"
77:37-77:38::b :: "{v : GHC.Types.Int | v == b}"
77:46-77:55::maxNumber :: "{v : GHC.Types.Int | v == maxNumber}"
80:1-80:12::Main.examplePRNG :: "GHC.Types.Int -> GHC.Types.Int"
80:20-80:24::lq_anf$##7205759403792806154 :: "GHC.Types.Int"
80:25-80:26::lq_anf$##7205759403792806156 :: "GHC.Types.Int"
80:27-80:30::lq_anf$##7205759403792806158 :: "GHC.Types.Int"